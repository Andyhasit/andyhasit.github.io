{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/indie.js","webpack:///./lib/pillbug.js","webpack:///./src/homepage.js","webpack:///./src/index.js","webpack:///./src/menu.js","webpack:///./src/modal-yes-no.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;ACjFA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEO;AACP,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;;AAEA;;AAEO;AACP;AACA,C;;;;;;;;;;;;ACxNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAGA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGO;AACP;AACA;;;AAGO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,cAAc,OAAO;AACrB;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxWA;AAAA;AAAA;AAA0C;;AAE3B,uBAAuB,oDAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8D;AACF;;AAElC;AACQ;AACM;;AAExC;;AAEA,gBAAgB,mDAAG;;AAEnB,gBAAgB,8DAAc;AAC9B;AACA;AACA;;AAEA,SAAS,6CAAI;;AAEb,iBAAiB,sDAAM;AACvB,QAAQ,iDAAQ;AAChB,WAAW,GAAG;AACd;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA,EAAE,+DAAS;AACX,qBAAqB,oDAAM;AAC3B;AACA;AACA,cAAc,WAAW;AACzB,cAAc,WAAW;AACzB,cAAc,WAAW;;AAEzB;AACA,eAAe,mBAAmB;AAClC,eAAe,cAAc;AAC7B,eAAe,eAAe;;AAE9B;AACA,GAAG;AACH,gBAAgB,sDAAQ;;AAExB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;;;;;AAKA,c;;;;;;;;;;;;ACpEA;AAAA;AAAA;AAA0C;;AAE1C;AACA;AACA,gDAAgD;AAChD;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGe,mBAAmB,oDAAI;AACtC;AACA,6CAA6C;AAC7C,mCAAmC,SAAS,eAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA,C;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAA2C;;;AAG5B,yBAAyB,qDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","\nconst c = console;\n\nexport class Database {\n  constructor(dbName, schema) {\n    this.schema = schema\n    this._caches = {}\n    this._fullyLoaded = {}\n    this._dbp = new Promise((resolve, reject) => {\n      let openreq = indexedDB.open(dbName, schema.version())\n      openreq.onerror = () => reject(openreq.error)\n      openreq.onsuccess = () => resolve(openreq.result)\n      openreq.onupgradeneeded = (event) => {\n        // First time setup: create an empty object store\n        schema.upgrade(openreq.result, event.oldVersion)\n      }\n    })\n  }\n  dump() {\n    let data = {}, promises=[];\n    for (let store in this.schema._stores) {\n      promises.push(this.getAll(store).then(rows => data[store] = rows))\n    }\n    return Promise.all(promises).then(x => data)\n  }\n  _cacheOf(store) {\n    if (!this._caches.hasOwnProperty(store)) {\n      this._caches[store] = {}\n    }\n    return this._caches[store]\n  }\n  _wrap(store, action, type, ...args) {\n    return this._dbp.then(db => new Promise((resolve, reject) => {\n      let transaction = db.transaction(store, type)\n      let request = transaction.objectStore(store)[action](...args)\n      transaction.oncomplete = () => resolve(request.result)\n      transaction.onabort = transaction.onerror = () => reject(transaction.error)\n    }))\n  }\n  put(store, record) {\n    return this._wrap(store, 'put', 'readwrite', record).then(id => {\n      record.id = id\n      this._cacheOf(store)[id] = record\n      return record\n    })\n  }\n  del(store, record) {\n    return this._wrap(store, 'delete', 'readwrite', record.id).then(id => {\n      delete this._cacheOf(store)[record.id]\n    })\n  }\n  get(store, id) {\n    let record = this._cacheOf(store)[id]\n    if (record == undefined) {\n      return this._wrap(store, 'get', undefined, id).then(record => {\n        this._cacheOf(store)[id] = record\n        return record\n      })\n    } else {\n      return Promise.resolve(record)\n    }\n  }\n  getAll(store) {\n    if (this._fullyLoaded[store]) {\n      return Promise.resolve(Object.values(this._cacheOf(store)))\n    } else {\n      return this._wrap(store, 'getAll').then(records => {\n        let cache = this._cacheOf(store)\n        this._fullyLoaded[store] = true\n        records.map(record => cache[record.id] = record)\n        return records\n      })\n    }\n  }\n  _criteriaMatch(record, criteria) {\n    for (let key in criteria) {\n      if (record[key] !== criteria[key]) {\n        return false\n      }\n    }\n    return true\n  }\n  _fetchOne(store, criteria) {\n\n    // UNTESTED\n    //Todo: add query caching\n    return this._dbp.then(db => new Promise((resolve, reject) => {\n      let records = []\n      let cursorTrans = db.transaction(store).objectStore(store).openCursor()\n      cursorTrans.onerror = error => c.log(error)\n      cursorTrans.onsuccess = event => {\n        var cursor = event.target.result\n        if (cursor) {\n          let record = cursor.value\n          if (this._criteriaMatch(record, criteria)) {\n            records.push(record)\n          } else {\n            cursor.continue()\n          }\n        }\n        else {\n          resolve(records)\n        }\n      }\n    }))\n  }\n  filter(store, criteria) {\n    //Todo: add query caching\n    return this._dbp.then(db => new Promise((resolve, reject) => {\n      let records = []\n      let cursorTrans = db.transaction(store).objectStore(store).openCursor()\n      cursorTrans.onerror = error => c.log(error)\n      cursorTrans.onsuccess = event => {\n        var cursor = event.target.result\n        if (cursor) {\n          let record = cursor.value\n          if (this._criteriaMatch(record, criteria)) {\n            records.push(record)\n          }\n          cursor.continue();\n        }\n        else {\n          resolve(records)\n        }\n      }\n    }))\n  }\n  getParent(childStore, parentStore, child) {\n    let fkName = this.schema.getFkName(parentStore)\n    let parentId = child[fkName]\n    if (parentId == undefined ) {\n      return Promise.resolve(undefined)\n    }\n    return this.get(parentStore, parentId)\n  }\n  getChildren(parentStore, childStore, parentId) {\n    //Todo : cache\n    return this._dbp.then(db => new Promise((resolve, reject) => {\n      let transaction = db.transaction(childStore)\n      let request = transaction.objectStore(childStore).index(parentStore).get(parentId)\n      transaction.oncomplete = () => resolve(request.result)\n      transaction.onabort = transaction.onerror = () => reject(transaction.error)\n    }))\n  }\n  setParent(childStore, parentStore, childRecord, parentId) {\n    let fkName = this.schema.getFkName(parentStore)\n    childRecord[fkName] = parentId\n    return this.put(childStore, childRecord)\n  }\n}\n\n/*\n  IndexDb allows versioning. It would be a shame to lose that, but we also want one description of the model.\n\n  We tap into that by \n  \n  The idea is that we define the stores and relationships once.\n\n  \n  or:\n    db.getParent('table1', 'table2', record)\n    db.getChildren('table1', 'table2', record)\n    db.getRelated('table1', 'table2', record) // many to many\n    db.setParent('table1', 'table2', record, parent)\n    db.link('table1', 'table2', record1, record2)\n    db.unlink('table1', 'table2', record1, record2)\n\n    The many__many tables will have predictable names.\n\n    Need to ensure we can wrap multiple in a transaction.\n\n\nMay not want to load everything in memory, e.g. child objects.\nBut once a specific query has been called, e.g. getChildren of x, then so long as all other changes are cached\n\nTodo:\n  Make a generic backend agnostic CachedDatabase on which we must implement a wrap method\n\n*/\n\nexport class Schema {\n  constructor(conf={keyPath: \"id\", autoIncrement: true}) {\n    this.conf = conf\n    this._versions = []\n    this._stores = {}\n  }\n  getFkName(parentStore){\n    return `__${parentStore}Id`\n  }\n  addVersion(fn) {\n    this._versions.push(fn)\n  }\n  version() {\n    return this._versions.length + 1\n  }\n  upgrade(idb, oldVersion) {\n    this._idb = idb\n    this._versions.forEach((fn, version) => {\n      if (version >= oldVersion) {\n        fn(this)\n      }\n    })\n  }\n  addStore(name, conf=this.conf) {\n    let store = this._idb.createObjectStore(name, conf)\n    this._stores[name] = store\n    return store\n  }\n  oneToMany(store1, store2) {\n    this._stores[store2].createIndex(store1, `__${store1}Id`);\n  }\n\n}\n\nexport function deleteIdb(dbName) {\n  indexedDB.deleteDatabase(dbName)\n}","/*\nPillbug version 0.0.1\n\n\n*/\n\nconst c = console;\nexport class App {\n  constructor() {\n    this._eventWatchers = {}\n    this._views = {}\n  }\n  view(cls, name) {\n    let view = new cls(this)\n    view.draw()\n    if (name) {\n      this._views[name] = view\n    }\n  }\n  emit(event, data) {\n    this._watchers(event).forEach(w => w(data))\n  }\n  on(event, callback) {\n    this._watchers(event).push(callback)\n  }\n  _watchers(event) {\n    let watchers = this._eventWatchers[event]\n    if (watchers == undefined) {\n      watchers = []\n      this._eventWatchers[event] =  watchers\n    }\n    return watchers\n  }\n}\n\nexport class ModalContainer {\n  constructor(id) {\n    //c.log(h('#' + id))\n    this._el = h('#' + id)\n  }\n  showModal(modal) {\n    modal.draw()\n    this._el.inner(modal)\n    return modal.promise\n      .then(result => {          \n        this._el.clear()\n        return result\n      })\n      .catch(error => {\n        this._el.clear()\n        return error\n      })\n  }\n}\n\n\nexport class View {\n  constructor(app, props, key) {\n    this._app = app\n    this._props = props\n    this._key = key\n    this._vCache = {}\n    this._matchers = {}\n    this._vals = {}\n    this.v = this._view.bind(this)\n  }\n  draw() {\n    this._draw(h, this.v, this._app, this._props, this._key, this)\n  }\n  wrap(v) {\n    /*\n    if (el instanceof NodeWrapper || el instanceof View) {\n      this.root = el\n      this.el = el.el\n    } else {\n      throw new TypeError(\"View.wrap() only accepts types: NodeWrapper, View\")\n    }\n    */\n    this.root = v\n    this.el = v.el\n    return v\n  }\n  match(prop, fn) {\n    if (!this._matchers.hasOwnProperty(prop)) {\n      this._matchers[prop] = []\n    }\n    this._matchers[prop].push(fn)\n  }\n  update(props) {\n    this._update(h, this.v, this._app, props, this._key, this)\n  }\n  _update(h,v,a,p,k,s) {\n    for (let prop in s._matchers) {\n      let val = p[prop];\n      if (s._vals[prop] !== val) {\n        s._matchers[prop].forEach(fn => {\n          fn(val, p)\n        })\n      }\n      s._vals[prop] = val\n    }\n  }\n  _view(cls, props, key) {\n    let view;\n    if (key == undefined) {\n      view = new cls(this._app, props)\n      view.draw()\n    } else {\n      let className = cls.name;\n      if (!this._vCache.hasOwnProperty(className)) {\n        this._vCache[className] = {}\n      }\n      let cacheForType = this._vCache[className];\n      if (cacheForType.hasOwnProperty(key)) {\n        view = cacheForType[key]\n      } else {\n        view = new cls(this._app, props, key)\n        view.draw()\n        cacheForType[key] = view\n      }\n    }\n    view.update(props)\n    return view\n  }\n}\n\n\nexport class Modal extends View {\n  _draw(h,v,a,p,k,s) {\n    s.wrap(s.overlay(h,v,a,p,k,s).on('click', e => {\n        if (e.target == s.el) {\n          s.reject('user-cancelled')\n        }\n      }\n    ))\n    s.promise = new Promise((resolve, reject) => {\n      s.resolve = resolve\n      s.reject = reject\n    })\n    s.root.inner(s.content(h,v,a,p,k,s))\n  }\n}\n\n\nexport function h(tag) {\n  return new NodeWrapper(tag)\n}\n\n\nexport class NodeWrapper {\n  constructor(tag) {\n    if (tag.startsWith('#')) {\n      this.el = document.getElementById(tag.substr(1))\n    } else {\n      this.el = document.createElement(tag)\n    }\n  }\n  atts(atts) {\n    for (let key in atts) {\n      this.el.setAttribute(key, atts[key])\n    }\n    return this\n  }\n  checked(val) {\n    this.el.checked = val\n    return this\n  }\n  class(className) {\n    /*\n    classList.add(\"mystyle\")\n    element.classList.toggle(\"mystyle\")\n    .remove(\"mystyle\")\n    */\n    this.el.className = className\n    return this\n  }\n  clear() {\n    this.el.innerHTML = ''\n    return this\n  }\n  on(event, callback) {\n    this.el.addEventListener(event, callback)\n    return this\n  }\n  id(id) {\n    this.el.id = id\n    return this\n  }\n  inner(inner) {\n    this.el.innerHTML = ''\n    if (!Array.isArray(inner)) {\n      inner = [inner]\n    }\n    let fragment = document.createDocumentFragment()\n    inner.forEach(child => {\n      if (child instanceof NodeWrapper || child instanceof View) {\n        fragment.appendChild(child.el)\n      } else if (child instanceof Node) {\n        fragment.appendChild(child)\n      } else {\n        fragment.appendChild(document.createTextNode(child.toString()))\n      }\n    })\n    this.el.appendChild(fragment)\n    return this\n  }\n  html(html) {\n    this.el.innerHTML = html\n    return this\n  }\n  text(text) {\n    this.el.textContent = text\n    return this\n  }\n}\n\n/*\n\nRouting.\n\nkey won't work if no args, but we want it to!\n\nparams vs vars\n*/\n\nexport class Router {\n  constructor(app, id, routes) {\n    this._app = app;\n    this.pageContainer = new PageContainer(this._app, id);\n    this.routes = routes.map(ar => new Route(...ar));\n    window.addEventListener('hashchange', e => this._hashChanged());\n    window.addEventListener('load', e => this._hashChanged());\n    /*\n    //window.addEventListener('load', router);\n    window.addEventListener('popstate', () => {\n     contentDiv.innerHTML = routes[window.location.pathname];\n    }\n    */\n  }\n  add(pattern, cls, key) {\n    this.routes.push(new Route(pattern, cls, keyFn))\n  }\n  _hashChanged(e) {\n    let url = location.hash.slice(1) || '/';\n    let route = this._getRoute(url);\n    if (!route) {\n      throw new Error('Route not matched: ' + url)\n    }\n    this.pageContainer.switch(route)\n    //window.history.pushState({}, url, window.location.origin + url);\n  }\n  _goto(url) {\n\n  }\n  _getRoute(url) {\n    let len = this.routes.length;\n    for (let i=0; i<len; i++) {\n      let route = this.routes[i];\n      if (route.matches(url)) {\n        return route\n      }\n    }\n  }\n}\n\nexport class PageContainer extends View{\n  constructor(app, id) {\n    super(app)\n    this.wrap(h('#' + id))\n  }\n  switch(route) {\n    this.root.inner(this._view(route.cls, route.props, route.keyFn(route.props))) // route.keyFn(route.props)\n  }\n}\n\nexport class Route {\n  constructor(pattern, cls, keyFn) {\n    //'todos/{id:int}?name,age'\n    let paramStr;\n    this.cls = cls;\n    this.keyFn = keyFn; //TODO - implement/use\n    [pattern, paramStr] = pattern.split('?')\n    this.pattern = pattern\n    this.chunks = pattern.split('/').map(s => {\n      if (s.startsWith('{')) {\n        return new RouteArg(s.slice(1,-1))\n      }\n      return s\n    })\n    this.params = {}\n    if (paramStr) {\n      paramStr.split(',').forEach(s => {\n        let r = new RouteArg(s.trim());\n        this.params[r.name] = r;\n      })\n    }\n  }\n  /*\n  _extract(str) {\n    return str.match(/\\{.+?\\}/g).map(x => x.slice(1,-1))\n  }\n  */\n  matches(url) {\n    let main, paramStr, chunks;\n    [main, paramStr] = url.split('?')\n    chunks = main.split('/')\n    let defChunk, testChunk, props = {}, i=0, end=this.chunks.length, mismatch=false;\n    if (end == chunks.length) {\n      while (true) {\n        defChunk = this.chunks[i];\n        testChunk = chunks[i];\n        if (defChunk instanceof RouteArg) {\n          props[defChunk.name] = defChunk.convert(testChunk)\n        } else if (defChunk !== testChunk) {\n          mismatch = true;\n          break;\n        }\n        i ++;\n        if (i > end) {\n          break;\n        }\n      }\n      if (!mismatch) {\n        if (paramStr) {\n          paramStr.split('&').forEach(e => {\n            let k, v;\n            [k,v] = e.split('=')\n            if (this.params.hasOwnProperty(k)) {\n              props[k] = this.params[k].convert(v)\n            }\n          })\n        }\n        this.props = props // for this run only\n        return true\n      }\n    }\n    return false\n  }\n}\n\nexport class RouteArg {\n  constructor(str) {\n    // No error checks :-(\n    let name, conv;\n    [name, conv] = str.split(':')\n    this.name = name\n    switch (conv) {\n      case 'int':\n        this.conv = v => parseInt(v);\n        break;\n      case 'float':\n        this.conv = v => parseFloat(v);\n        break;\n      default:\n        this.conv = v => v;\n    }\n  }\n  convert(val) {\n    return this.conv(val)\n  }\n}\n","import {View, h} from '../lib/pillbug.js';\n\nexport default class HomePage extends View {\n  _draw(h,v,a,p,k,s) {\n    s.wrap(h('div'))\n    a.on('tasks-updated', e => s.drawTodos(h,v,a,p,k,s))\n  }\n  drawTodos(h,v,a,p,k,s) {\n    s.root.inner(a.tasks.map( todo => \n      h('div').inner(todo.text)\n    ))\n  }\n}","import {App, ModalContainer, Router} from '../lib/pillbug.js';\nimport {Database, Schema, deleteIdb} from '../lib/indie.js';\n\nimport Menu from './menu';\nimport HomePage from './homepage';\nimport ModalYesNo from './modal-yes-no';\n\nconst c = console;\n\nconst app = new App()\n\napp.modal = new ModalContainer('modal-container')\napp.showModal = function(modal) {\n  app.modal.showModal(modal);\n}\n\napp.view(Menu)\n\napp.router = new Router(app, 'page-container', [\n  ['/', HomePage, props => 1],\n  ['todos/{id}?name,age', ''],\n])\n\napp.goto = function(url) {\n  // so far not used as we use hrefs\n  //this.emit('goto', page)\n  //window.history.pushState({}, window.location + url, window.location.origin + url);\n}\n\napp.loadData = function() {\n  deleteIdb('mop-todos')\n  const schema = new Schema()\n  schema.addVersion(schema => {\n    let days = schema.addStore('day')\n    days.put({day: 'mon'})\n    days.put({day: 'tue'})\n    days.put({day: 'wed'})\n\n    let tasks = schema.addStore('task')\n    tasks.put({text: 'Breadkfast'})\n    tasks.put({text: 'Lunch'})\n    tasks.put({text: 'Dinner'})\n\n    schema.oneToMany('day', 'task')\n  })\n  this.db = new Database('mop-todos', schema)\n\n  this.db.getAll('task').then(tasks => {\n    this.tasks = tasks\n\n    this.db.getAll('day').then(days => {\n      this.days = days\n      this.db.setParent('task', 'day', this.tasks[1], this.days[1].id).then(r => {\n        this.db.getChildren('day', 'task', this.days[1].id).then(r => c.log(r))\n        this.db.getParent('task', 'day', this.tasks[1]).then(r => c.log(r))\n        this.db.getParent('task', 'day', this.tasks[0]).then(r => c.log(r))\n        this.emit('tasks-updated')\n\n        //this.showModal(new ModalYesNo('Really?'))\n      })\n    })\n  })\n\n}\n\n\n\n\napp.loadData()","import {View, h} from '../lib/pillbug.js';\n\nfunction download(filename, text) {\n  var element = document.createElement('a');\n  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\n  element.setAttribute('download', filename);\n\n  element.style.display = 'none';\n  document.body.appendChild(element);\n\n  element.click();\n\n  document.body.removeChild(element);\n}\n\n\nexport default class Menu extends View {\n  _draw(h,v,a,p,k,s) {\n    let showMenuBtn = h('span').html('&#9776;').class('menu-button').on('click', e => s.showMenu())\n    let hideMenuBtn = h('a').atts({href:\"#\"}).html('&times;').class('closebtn').on('click', e => s.hideMenu())\n    s.menuDiv = h('div').id('menu').class('overlay').inner([\n      hideMenuBtn,\n      h('div').class('overlay-content').inner([\n        s.getMenuEntry(a, h, 'Home', ''),\n        s.getMenuEntry(a, h, 'Page2', 'page2'),\n        s.downloadButton(h,v,a,p,k,s)\n        ])\n      ])\n    s.wrap(h('#menu-container')).inner([\n      s.menuDiv, \n      showMenuBtn\n      ])\n  }\n  downloadButton(h,v,a,p,k,s) {\n    return h('a').atts({href:\"#\"}).text('Download').on('click', e => {\n      a.db.dump().then(data => {\n        download('test.txt', JSON.stringify(data))\n        this.hideMenu()\n      })\n    })\n  }\n  getMenuEntry(a, h, text, route) {\n    return h('a').atts({href:\"#\" + route}).text(text).on('click', e => {\n      this.hideMenu()\n      //a.goto(route)\n    })\n  }\n  showMenu() {\n    this.menuDiv.atts({style: 'width: 70%'})\n  }\n  hideMenu() {\n    this.menuDiv.atts({style: 'width: 0'})\n  }\n}","import {Modal, h} from '../lib/pillbug.js';\n\n\nexport default class ModalYesNo extends Modal {\n  overlay(h,v,a,p,k,s) {\n    return h('div').class('modal-background')\n  }\n  content(h,v,a,p,k,s) {\n    return h('div').class('modal-content modal-animate').inner([\n      h('button').text('OK').on('click', e => s.resolve(222521)),\n      h('button').text('Cancel').on('click', e => s.reject('user-cancelled')),\n    ])\n  }\n}\n"],"sourceRoot":""}