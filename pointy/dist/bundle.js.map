{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/indie.js","webpack:///./lib/pillbug.js","webpack:///./src/index.js","webpack:///./src/modals/AddTaskModal.js","webpack:///./src/routes.js","webpack:///./src/schema.js","webpack:///./src/views/homepage.js","webpack:///./src/views/menu.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;ACjFA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEO;AACP,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA,mBAAmB,OAAO,IAAI,OAAO;AACrC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,C;;;;;;;;;;;;AC1TA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAGA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGO;AACP;AACA;;;AAGO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,cAAc,OAAO;AACrB;AACA;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9WA;AAAA;AAAA;AAAA;AAAA;AAA8D;;AAE9B;AACG;AACL;;;AAG9B,gBAAgB,mDAAG;AACnB,SAAS,+CAAW;;AAEpB;AACA,mBAAmB,sDAAM,wBAAwB,+CAAM;AACvD,2BAA2B,8DAAc;AACzC,WAAW,mDAAI;AACf;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACtCA;AAAA;AAAA;AAA8C;;;AAG/B,yBAAyB,qDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe,qBAAqB,sBAAsB;AAC3F;AACA;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAyC;;AAED;;AAExC;AACA,QAAQ,uDAAQ;AAChB,WAAW,GAAG;AACd;;;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAA4D;;AAE5D,mBAAmB,oDAAM;;AAEzB,+DAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,CAAC;;AAED,eAAe,sDAAQ;;;;;;;;;;;;;;ACjBvB;AAAA;AAAA;AAAA;AAA6C;AACK;;;AAGnC,uBAAuB,oDAAI;AAC1C;AACA;AACA;AACA,sBAAsB,4DAAY;AAClC;AACA;AACA,SAAS;AACT,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAA6C;;AAE7C;AACA;AACA,gDAAgD;AAChD;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGe,mBAAmB,oDAAI;AACtC;AACA,6CAA6C;AAC7C,mCAAmC,SAAS,eAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA,C","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","\nconst c = console;\n\nexport class Database {\n  constructor(dbName, schema) {\n    this.schema = schema\n    this._caches = {}\n    this._fullyLoaded = {}\n    this._dbp = new Promise((resolve, reject) => {\n      let openreq = indexedDB.open(dbName, schema.getVersion())\n      openreq.onerror = () => reject(openreq.error)\n      openreq.onsuccess = () => {\n        schema.createFunctions(this)\n        resolve(openreq.result)\n      }\n      openreq.onupgradeneeded = (event) => {\n        // First time setup: create an empty object store\n        schema.upgrade(openreq.result, event.oldVersion)\n      }\n    })\n  }\n  ready() {\n    return this._dbp\n  }\n  dump() {\n    let data = {}, promises=[];\n    return this._dbp.then(db => {\n      let names = db.objectStoreNames, len = db.objectStoreNames.length;\n      for (let i=0;i<len;i++) {\n        let store = names[i];\n        promises.push(this.getAll(store).then(rows => data[store] = rows))\n      }\n      return Promise.all(promises).then(x => data)\n    });\n  }\n  _cacheOf(store) {\n    if (!this._caches.hasOwnProperty(store)) {\n      this._caches[store] = {}\n    }\n    return this._caches[store]\n  }\n  _wrap(store, action, type, ...args) {\n    return this._dbp.then(db => new Promise((resolve, reject) => {\n      let transaction = db.transaction(store, type)\n      let request = transaction.objectStore(store)[action](...args)\n      transaction.oncomplete = () => resolve(request.result)\n      transaction.onabort = transaction.onerror = () => reject(transaction.error)\n    }))\n  }\n  put(store, record) {\n    return this._wrap(store, 'put', 'readwrite', record).then(id => {\n      record.id = id\n      this._cacheOf(store)[id] = record\n      return record\n    })\n  }\n  del(store, record) {\n    return this._wrap(store, 'delete', 'readwrite', record.id).then(id => {\n      delete this._cacheOf(store)[record.id]\n    })\n  }\n  get(store, id) {\n    let record = this._cacheOf(store)[id]\n    if (record == undefined) {\n      return this._wrap(store, 'get', undefined, id).then(record => {\n        this._cacheOf(store)[id] = record\n        return record\n      })\n    } else {\n      return Promise.resolve(record)\n    }\n  }\n  getAll(store) {\n    if (this._fullyLoaded[store]) {\n      return Promise.resolve(Object.values(this._cacheOf(store)))\n    } else {\n      return this._wrap(store, 'getAll').then(records => {\n        let cache = this._cacheOf(store)\n        this._fullyLoaded[store] = true\n        records.map(record => cache[record.id] = record)\n        return records\n      })\n    }\n  }\n  _criteriaMatch(record, criteria) {\n    for (let key in criteria) {\n      if (record[key] !== criteria[key]) {\n        return false\n      }\n    }\n    return true\n  }\n  _fetchOne(store, criteria) {\n\n    // UNTESTED\n    //Todo: add query caching\n    return this._dbp.then(db => new Promise((resolve, reject) => {\n      let records = []\n      let cursorTrans = db.transaction(store).objectStore(store).openCursor()\n      cursorTrans.onerror = error => c.log(error)\n      cursorTrans.onsuccess = event => {\n        var cursor = event.target.result\n        if (cursor) {\n          let record = cursor.value\n          if (this._criteriaMatch(record, criteria)) {\n            records.push(record)\n          } else {\n            cursor.continue()\n          }\n        }\n        else {\n          resolve(records)\n        }\n      }\n    }))\n  }\n  filter(store, criteria) {\n    //Todo: add query caching\n    return this._dbp.then(db => new Promise((resolve, reject) => {\n      let records = []\n      let cursorTrans = db.transaction(store).objectStore(store).openCursor()\n      cursorTrans.onerror = error => c.log(error)\n      cursorTrans.onsuccess = event => {\n        var cursor = event.target.result\n        if (cursor) {\n          let record = cursor.value\n          if (this._criteriaMatch(record, criteria)) {\n            records.push(record)\n          }\n          cursor.continue();\n        }\n        else {\n          resolve(records)\n        }\n      }\n    }))\n  }\n  getParent(childStore, parentStore, child) {\n    let fkName = this.schema.getFkName(parentStore)\n    let parentId = child[fkName]\n    if (parentId == undefined ) {\n      return Promise.resolve(undefined)\n    }\n    return this.get(parentStore, parentId)\n  }\n  getLinked(storeName, store1, store2Record) {\n\n  }\n  getChildren(parentStore, childStore, parentRecord) {\n    //Todo : cache\n    return this._dbp.then(db => new Promise((resolve, reject) => {\n      let transaction = db.transaction(childStore)\n      let request = transaction.objectStore(childStore).index(parentStore).get(parentRecord.id)\n      transaction.oncomplete = () => resolve(request.result)\n      transaction.onabort = transaction.onerror = () => reject(transaction.error)\n    }))\n  }\n  setParent(childStore, parentStore, childRecord, parentRecord) {\n    let fkName = this.schema.getFkName(parentStore)\n    childRecord[fkName] = parentRecord.id\n    return this.put(childStore, childRecord)\n  }\n  link(store1, store2, store1Record, store2Record) {\n    let storeName = this.schema.getLinkStoreName(store1, store2);\n    let record = {}\n    record[this.schema.getFkName(store1)] = store1Record.id;\n    record[this.schema.getFkName(store2)] = store2Record.id;\n    return this.put(storeName, record)\n  }\n}\n\n/*\n  IndexDb allows versioning. It would be a shame to lose that, but we also want one description of the model.\n\n  We tap into that by \n  \n  The idea is that we define the stores and relationships once.\n\n  \n  or:\n    db.getParent('table1', 'table2', record)\n    db.getChildren('table1', 'table2', record)\n    db.getRelated('table1', 'table2', record) // many to many\n    db.setParent('table1', 'table2', record, parent)\n    db.link('table1', 'table2', record1, record2)\n    db.unlink('table1', 'table2', record1, record2)\n\n    The many__many tables will have predictable names.\n\n    Need to ensure we can wrap multiple in a transaction.\n\n\nMay not want to load everything in memory, e.g. child objects.\nBut once a specific query has been called, e.g. getChildren of x, then so long as all other changes are cached\n\nTodo:\n  Make a generic backend agnostic CachedDatabase on which we must implement a wrap method\n\n*/\n\nexport class Schema {\n  constructor(defaultConf={keyPath: \"id\", autoIncrement: true}) {\n    this.defaultConf = defaultConf\n    this._versions = []\n  }\n  addVersion(fn) {\n    this._versions.push(fn)\n  }\n  getVersion() {\n    return this._versions.length + 1\n  }\n  upgrade(idb, oldVersion) {\n    let schemaUpgrader = new SchemaUpgrader(this, idb, this.defaultConf)\n    this._versions.forEach((fn, version) => {\n      if (version >= oldVersion) {\n        fn(schemaUpgrader, true)\n      }\n    })\n  }\n  createFunctions(target) {\n    let schemaFunctionBuilder = new SchemaFunctionBuilder(this, target)\n    this._versions.forEach((fn, version) => {\n      fn(schemaFunctionBuilder, false)\n    })\n  }\n  getFkName(parentStore) {\n    return `__${parentStore}Id`\n  }\n  getLinkStoreName(store1, store2) {\n    return `m2m__${store1}__${store2}`\n  }\n}\n\n\nclass SchemaFunctionBuilder {\n  constructor(schema, target) {\n    this.schema = schema\n    this.target = target\n  }\n  capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1)\n  }\n  addStore(name) {\n    let capitalizedName = this.capitalize(name);\n    ['put', 'del', 'get', 'getAll'].forEach(method => {\n      this.target[method + capitalizedName] = function(arg) {\n        return this[method](name, arg)\n      }\n    })\n  }\n  oneToMany(parentStore, childStore) {\n    let parentCaps = this.capitalize(parentStore);\n    let childCaps = this.capitalize(childStore);\n    let pluralChildren = childCaps + 's'; //TODO: allow override in opts.\n    //Get parent as getChildParent(child)\n    this.target['get' + childCaps + parentCaps] = function(childRecord) {\n      return this.getParent(childStore, parentStore, childRecord)\n    }\n    //Get children as getParentChildren(parent)\n    this.target['get' + parentCaps + pluralChildren] = function(parentRecord) {\n      return this.getChildren(parentStore, childStore, parentRecord)\n    }\n    this.target['set' + childCaps + parentCaps] = function(childRecord, parentRecord) {\n      return this.setParent(childStore, parentStore, childRecord, parentRecord)\n    }\n  }\n  manyToMany(store1, store2) {\n    let storeName = this.schema.getLinkStoreName(store1, store2);\n    let store1Caps = this.capitalize(store1);\n    let store2Caps = this.capitalize(store2);\n    let pluralStore1 = store1Caps + 's';\n    let pluralStore2 = store2Caps + 's';\n    this.target['get' + store1Caps + pluralStore2] = function(store1Record) {\n      return this.getChildren(store2, storeName, store1Record)\n      //return this.getLinked(storeName, store2, store1Record) //tagtask(tag)\n    }\n    this.target['get' + store2Caps + pluralStore1] = function(store2Record) {\n      //return this.getLinked(storeName, store1, store2Record)\n    }\n    this.target['link' + store1Caps + 'to' + store2Caps] = function(store1Record, store2Record) {\n      db.link(store1, store2, store1Record, store2Record)\n    }\n    this.target['link' + store2Caps + 'to' + store1Caps] = function(store2Record, store1Record) {\n      db.link(store1, store2, store1Record, store2Record)\n    }\n    //TODO: test above, then add unlink\n  }\n}\n\n\nclass SchemaUpgrader {\n  constructor(schema, idb, defaultConf) {\n    this.schema = schema\n    this.idb = idb\n    this.stores = {}\n    this.defaultConf = defaultConf\n  }\n  addStore(name, conf=this.defaultConf) {\n    let store = this.idb.createObjectStore(name, conf)\n    this.stores[name] = store\n    return store\n  }\n  oneToMany(parent, child) {\n    this.stores[child].createIndex(parent, this.schema.getFkName(parent));\n  }\n  manyToMany(store1, store2) {\n    let store = this.idb.createObjectStore(this.schema.getLinkStoreName(store1, store2), this.defaultConf)\n    store.createIndex(store1, this.schema.getFkName(store1));\n    store.createIndex(store2, this.schema.getFkName(store2));\n  }\n}\n\nexport function deleteIdb(dbName) {\n  indexedDB.deleteDatabase(dbName)\n}","/*\nPillbug version 0.0.1\n\n\n*/\n\nconst c = console;\nexport class App {\n  constructor() {\n    this._eventWatchers = {}\n    this._views = {}\n  }\n  view(cls, name) {\n    let view = new cls(this)\n    view.draw()\n    if (name) {\n      this._views[name] = view\n    }\n  }\n  emit(event, data) {\n    this._watchers(event).forEach(w => w(data))\n  }\n  on(event, callback) {\n    this._watchers(event).push(callback)\n  }\n  _watchers(event) {\n    let watchers = this._eventWatchers[event]\n    if (watchers == undefined) {\n      watchers = []\n      this._eventWatchers[event] =  watchers\n    }\n    return watchers\n  }\n}\n\nexport class ModalContainer {\n  constructor(id) {\n    //c.log(h('#' + id))\n    this._el = h('#' + id)\n  }\n  showModal(modal) {\n    modal.draw()\n    this._el.inner(modal)\n    return new Promise((resolve, reject) => {\n      modal.promise\n      .then(result => {          \n        this._el.clear()\n        resolve(result)\n      })\n      .catch(error => {\n        this._el.clear()\n        reject(error)\n      })\n    })\n  }\n}\n\n\nexport class View {\n  constructor(app, props, key) {\n    this._app = app\n    this._props = props\n    this._key = key\n    this._vCache = {}\n    this._matchers = {}\n    this._vals = {}\n    this.v = this._view.bind(this)\n  }\n  draw() {\n    this._draw(h, this.v, this._app, this._props, this._key, this)\n  }\n  wrap(v) {\n    /*\n    if (el instanceof NodeWrapper || el instanceof View) {\n      this.root = el\n      this.el = el.el\n    } else {\n      throw new TypeError(\"View.wrap() only accepts types: NodeWrapper, View\")\n    }\n    */\n    this.root = v\n    this.el = v.el\n    return v\n  }\n  match(prop, fn) {\n    if (!this._matchers.hasOwnProperty(prop)) {\n      this._matchers[prop] = []\n    }\n    this._matchers[prop].push(fn)\n  }\n  update(props) {\n    this._update(h, this.v, this._app, props, this._key, this)\n  }\n  _update(h,v,a,p,k,s) {\n    for (let prop in s._matchers) {\n      let val = p[prop];\n      if (s._vals[prop] !== val) {\n        s._matchers[prop].forEach(fn => {\n          fn(val, p)\n        })\n      }\n      s._vals[prop] = val\n    }\n  }\n  _view(cls, props, key) {\n    let view;\n    if (key == undefined) {\n      view = new cls(this._app, props)\n      view.draw()\n    } else {\n      let className = cls.name;\n      if (!this._vCache.hasOwnProperty(className)) {\n        this._vCache[className] = {}\n      }\n      let cacheForType = this._vCache[className];\n      if (cacheForType.hasOwnProperty(key)) {\n        view = cacheForType[key]\n      } else {\n        view = new cls(this._app, props, key)\n        view.draw()\n        cacheForType[key] = view\n      }\n    }\n    view.update(props)\n    return view\n  }\n}\n\n\nexport class Modal extends View {\n  _draw(h,v,a,p,k,s) {\n    s.wrap(s.overlay(h,v,a,p,k,s).on('click', e => {\n        if (e.target == s.el) {\n          s.reject('user-cancelled')\n        }\n      }\n    ))\n    s.promise = new Promise((resolve, reject) => {\n      s.resolve = resolve\n      s.reject = reject\n    })\n    s.root.inner(s.content(h,v,a,p,k,s))\n  }\n}\n\n\nexport function h(tag) {\n  return new NodeWrapper(tag)\n}\n\n\nexport class NodeWrapper {\n  constructor(tag) {\n    if (tag.startsWith('#')) {\n      this.el = document.getElementById(tag.substr(1))\n    } else {\n      this.el = document.createElement(tag)\n    }\n  }\n  atts(atts) {\n    for (let key in atts) {\n      this.el.setAttribute(key, atts[key])\n    }\n    return this\n  }\n  checked(val) {\n    this.el.checked = val\n    return this\n  }\n  class(className) {\n    /*\n    classList.add(\"mystyle\")\n    element.classList.toggle(\"mystyle\")\n    .remove(\"mystyle\")\n    */\n    this.el.className = className\n    return this\n  }\n  clear() {\n    this.el.innerHTML = ''\n    return this\n  }\n  focus(){\n    this.el.focus()\n    return this\n  }\n  on(event, callback) {\n    this.el.addEventListener(event, callback)\n    return this\n  }\n  id(id) {\n    this.el.id = id\n    return this\n  }\n  inner(inner) {\n    this.el.innerHTML = ''\n    if (!Array.isArray(inner)) {\n      inner = [inner]\n    }\n    let fragment = document.createDocumentFragment()\n    inner.forEach(child => {\n      if (child instanceof NodeWrapper || child instanceof View) {\n        fragment.appendChild(child.el)\n      } else if (child instanceof Node) {\n        fragment.appendChild(child)\n      } else {\n        fragment.appendChild(document.createTextNode(child.toString()))\n      }\n    })\n    this.el.appendChild(fragment)\n    return this\n  }\n  html(html) {\n    this.el.innerHTML = html\n    return this\n  }\n  text(text) {\n    this.el.textContent = text\n    return this\n  }\n}\n\n/*\n\nRouting.\n\nkey won't work if no args, but we want it to!\n\nparams vs vars\n*/\n\nexport class Router {\n  constructor(app, id, routes) {\n    this._app = app;\n    this.pageContainer = new PageContainer(this._app, id);\n    this.routes = routes.map(ar => new Route(...ar));\n    window.addEventListener('hashchange', e => this._hashChanged());\n    window.addEventListener('load', e => this._hashChanged());\n    /*\n    //window.addEventListener('load', router);\n    window.addEventListener('popstate', () => {\n     contentDiv.innerHTML = routes[window.location.pathname];\n    }\n    */\n  }\n  add(pattern, cls, key) {\n    this.routes.push(new Route(pattern, cls, keyFn))\n  }\n  _hashChanged(e) {\n    let url = location.hash.slice(1) || '/';\n    let route = this._getRoute(url);\n    if (!route) {\n      throw new Error('Route not matched: ' + url)\n    }\n    this.pageContainer.switch(route)\n    //window.history.pushState({}, url, window.location.origin + url);\n  }\n  _goto(url) {\n\n  }\n  _getRoute(url) {\n    let len = this.routes.length;\n    for (let i=0; i<len; i++) {\n      let route = this.routes[i];\n      if (route.matches(url)) {\n        return route\n      }\n    }\n  }\n}\n\nexport class PageContainer extends View{\n  constructor(app, id) {\n    super(app)\n    this.wrap(h('#' + id))\n  }\n  switch(route) {\n    this.root.inner(this._view(route.cls, route.props, route.keyFn(route.props)))\n  }\n}\n\nexport class Route {\n  constructor(pattern, cls, keyFn) {\n    //'todos/{id:int}?name,age'\n    let paramStr;\n    this.cls = cls;\n    this.keyFn = keyFn || function(){return 1}; //Default is for pages to be cached.\n    [pattern, paramStr] = pattern.split('?')\n    this.pattern = pattern\n    this.chunks = pattern.split('/').map(s => {\n      if (s.startsWith('{')) {\n        return new RouteArg(s.slice(1,-1))\n      }\n      return s\n    })\n    this.params = {}\n    if (paramStr) {\n      paramStr.split(',').forEach(s => {\n        let r = new RouteArg(s.trim());\n        this.params[r.name] = r;\n      })\n    }\n  }\n  /*\n  _extract(str) {\n    return str.match(/\\{.+?\\}/g).map(x => x.slice(1,-1))\n  }\n  */\n  matches(url) {\n    let main, paramStr, chunks;\n    [main, paramStr] = url.split('?')\n    chunks = main.split('/')\n    let defChunk, testChunk, props = {}, i=0, end=this.chunks.length, mismatch=false;\n    if (end == chunks.length) {\n      while (true) {\n        defChunk = this.chunks[i];\n        testChunk = chunks[i];\n        if (defChunk instanceof RouteArg) {\n          props[defChunk.name] = defChunk.convert(testChunk)\n        } else if (defChunk !== testChunk) {\n          mismatch = true;\n          break;\n        }\n        i ++;\n        if (i > end) {\n          break;\n        }\n      }\n      if (!mismatch) {\n        if (paramStr) {\n          paramStr.split('&').forEach(e => {\n            let k, v;\n            [k,v] = e.split('=')\n            if (this.params.hasOwnProperty(k)) {\n              props[k] = this.params[k].convert(v)\n            }\n          })\n        }\n        this.props = props // for this run only\n        return true\n      }\n    }\n    return false\n  }\n}\n\nexport class RouteArg {\n  constructor(str) {\n    // No error checks :-(\n    let name, conv;\n    [name, conv] = str.split(':')\n    this.name = name\n    switch (conv) {\n      case 'int':\n        this.conv = v => parseInt(v);\n        break;\n      case 'float':\n        this.conv = v => parseFloat(v);\n        break;\n      default:\n        this.conv = v => v;\n    }\n  }\n  convert(val) {\n    return this.conv(val)\n  }\n}\n","import {App, ModalContainer, Router} from '../lib/pillbug.js';\n\nimport Menu from './views/menu';\nimport AppDatabase from './schema';\nimport routes from './routes';\n\n\nconst app = new App();\napp.db = AppDatabase;\n\napp.db.ready().then(() => {\n  app.router = new Router(app, 'page-container', routes);\n  app.modalContainer = new ModalContainer('modal-container')\n  app.view(Menu)\n  app.refreshTasks()\n});\n\n\napp.showModal = function(modal) {\n  return app.modalContainer.showModal(modal);\n}\n\napp.goto = function(url) {\n  // so far not used as we use hrefs\n  //this.emit('goto', page)\n  //window.history.pushState({}, window.location + url, window.location.origin + url);\n}\n\napp.refreshTasks = function() {\n  this.db.getAll('task').then(tasks =>\n    this.emit('tasks-updated', tasks)\n  )\n}\n\napp.addTask = function(task) {\n  this.db.putTask(task).then(task => {\n    this.refreshTasks()\n  })\n}\n","import {Modal, h} from '../../lib/pillbug.js';\n\n\nexport default class ModalYesNo extends Modal {\n  overlay(h,v,a,p,k,s) {\n    return h('div').class('modal-background')\n  }\n  content(h,v,a,p,k,s) {\n    let text = '';\n    let input = h('input').atts({autofocus:true}).on('change', e => {text = e.target.value})\n    return h('div').class('modal-content modal-animate').inner([\n      h('div').inner([\n        input\n      ]),\n      h('button').text('OK').on('click', e => s.resolve({text: text})),\n      h('button').text('Cancel').on('click', e => s.reject('user-cancelled')),\n    ])\n  }\n}\n","import {Router} from '../lib/pillbug.js';\n\nimport HomePage from './views/homepage';\n\nconst routes = [\n  ['/', HomePage],\n  ['todos/{id}?name,age', ''],\n]\n\n\nexport {routes as default};","import {Database, Schema, deleteIdb} from '../lib/indie.js';\n\nconst schema = new Schema()\n\ndeleteIdb('mop-todos')\n\nschema.addVersion((schema, isUpgrade) => {\n  let days = schema.addStore('day')\n  let tasks = schema.addStore('task')\n  let tags = schema.addStore('tag')\n  schema.oneToMany('day', 'task')\n  schema.manyToMany('tag', 'task')\n  if (isUpgrade) {\n    days.put({day: 'mon'})\n  }\n})\n\nconst db = new Database('mop-todos', schema)\n\nexport {db as default};","import {View, h} from '../../lib/pillbug.js';\nimport AddTaskModal from '../modals/AddTaskModal';\n\n\nexport default class HomePage extends View {\n  _draw(h,v,a,p,k,s) {\n    s.tasksUL = h('ul')\n    s.btnAdd = h('button').text('Add').on('click', e => {\n      a.showModal(new AddTaskModal())\n        .then(task => {\n          a.addTask(task)\n        })\n        .catch(e => {})\n    })\n    s.wrap(h('div').inner([\n      s.btnAdd,\n      s.tasksUL\n    ]))\n    a.on('tasks-updated', tasks => s.drawTasksUl(h,s,tasks))\n    c.log(994)\n  }\n  drawTasksUl(h,s,tasks) {\n    s.tasksUL.inner(tasks.map( task => \n      h('div').inner(task.text)\n    ))\n  }\n}","import {View, h} from '../../lib/pillbug.js';\n\nfunction download(filename, text) {\n  var element = document.createElement('a');\n  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\n  element.setAttribute('download', filename);\n\n  element.style.display = 'none';\n  document.body.appendChild(element);\n\n  element.click();\n\n  document.body.removeChild(element);\n}\n\n\nexport default class Menu extends View {\n  _draw(h,v,a,p,k,s) {\n    let showMenuBtn = h('span').html('&#9776;').class('menu-button').on('click', e => s.showMenu())\n    let hideMenuBtn = h('a').atts({href:\"#\"}).html('&times;').class('closebtn').on('click', e => s.hideMenu())\n    s.menuDiv = h('div').id('menu').class('overlay').inner([\n      hideMenuBtn,\n      h('div').class('overlay-content').inner([\n        s.getMenuEntry(a, h, 'Home', ''),\n        s.getMenuEntry(a, h, 'Page2', 'page2'),\n        s.downloadButton(h,v,a,p,k,s)\n        ])\n      ])\n    s.wrap(h('#menu-container')).inner([\n      s.menuDiv, \n      showMenuBtn\n      ])\n  }\n  downloadButton(h,v,a,p,k,s) {\n    return h('a').atts({href:\"#\"}).text('Download').on('click', e => {\n      a.db.dump().then(data => {\n        download('pointydb.json', JSON.stringify(data))\n        this.hideMenu()\n      })\n    })\n  }\n  getMenuEntry(a, h, text, route) {\n    return h('a').atts({href:\"#\" + route}).text(text).on('click', e => {\n      this.hideMenu()\n      //a.goto(route)\n    })\n  }\n  showMenu() {\n    this.menuDiv.atts({style: 'width: 70%'})\n  }\n  hideMenu() {\n    this.menuDiv.atts({style: 'width: 0'})\n  }\n}"],"sourceRoot":""}